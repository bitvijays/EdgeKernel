(* Generated by ./config.exe configure -t hvt --dhcp false (2020-03-27 09:37:22-00:00). *)

open Lwt.Infix
let return = Lwt.return
let run t = OS.Main.run t ; exit
0

let _ = Printexc.record_backtrace true

module Ethernet1 = Ethernet.Make(Netif)

module Arp1 = Arp.Make(Ethernet1)(OS.Time)

module Static_ipv41 = Static_ipv4.Make(Mirage_crypto_rng)(Mclock)(Ethernet1)
  (Arp1)

module Icmpv41 = Icmpv4.Make(Static_ipv41)

module Udp1 = Udp.Make(Static_ipv41)(Mirage_crypto_rng)

module Tcp1 = Tcp.Flow.Make(Static_ipv41)(OS.Time)(Mclock)(Mirage_crypto_rng)

module Tcpip_stack_direct1 = Tcpip_stack_direct.Make(OS.Time)
  (Mirage_crypto_rng)(Netif)(Ethernet1)(Arp1)(Static_ipv41)(Icmpv41)(Udp1)
  (Tcp1)

module Conduit_mirage1 = Conduit_mirage.With_tcp(Tcpip_stack_direct1)

module Resolver_mirage1 = Resolver_mirage.Make_with_stack(Mirage_crypto_rng)
  (Mclock)(Tcpip_stack_direct1)

module Unikernel1 = Unikernel.Client(OS.Time)(Console_solo5)
  (Resolver_mirage1)(Conduit_mirage)

module Mirage_logs1 = Mirage_logs.Make(Pclock)

let net11 = lazy (
  Netif.connect (Key_gen.interface ())
  )

let time1 = lazy (
  return ()
  )

let ethernet1 = lazy (
  let __net11 = Lazy.force net11 in
  __net11 >>= fun _net11 ->
  Ethernet1.connect _net11
  )

let random1 = lazy (
  Mirage_crypto_entropy.initialize (module Mirage_crypto_rng.Fortuna)
  )

let mclock1 = lazy (
  return ()
  )

let arp1 = lazy (
  let __ethernet1 = Lazy.force ethernet1 in
  let __time1 = Lazy.force time1 in
  __ethernet1 >>= fun _ethernet1 ->
  __time1 >>= fun _time1 ->
  Arp1.connect _ethernet1
  )

let ipv411 = lazy (
  let __random1 = Lazy.force random1 in
  let __mclock1 = Lazy.force mclock1 in
  let __ethernet1 = Lazy.force ethernet1 in
  let __arp1 = Lazy.force arp1 in
  __random1 >>= fun _random1 ->
  __mclock1 >>= fun _mclock1 ->
  __ethernet1 >>= fun _ethernet1 ->
  __arp1 >>= fun _arp1 ->
  Static_ipv41.connect ~ip:(Key_gen.ipv4 ()) ?gateway:(Key_gen.ipv4_gateway ())
                    _ethernet1 _arp1
  )

let icmpv41 = lazy (
  let __ipv411 = Lazy.force ipv411 in
  __ipv411 >>= fun _ipv411 ->
  Icmpv41.connect _ipv411
  )

let udp1 = lazy (
  let __ipv411 = Lazy.force ipv411 in
  let __random1 = Lazy.force random1 in
  __ipv411 >>= fun _ipv411 ->
  __random1 >>= fun _random1 ->
  Udp1.connect _ipv411
  )

let tcp1 = lazy (
  let __ipv411 = Lazy.force ipv411 in
  let __time1 = Lazy.force time1 in
  let __mclock1 = Lazy.force mclock1 in
  let __random1 = Lazy.force random1 in
  __ipv411 >>= fun _ipv411 ->
  __time1 >>= fun _time1 ->
  __mclock1 >>= fun _mclock1 ->
  __random1 >>= fun _random1 ->
  Tcp1.connect _ipv411
  )

let stackv4_1 = lazy (
  let __time1 = Lazy.force time1 in
  let __random1 = Lazy.force random1 in
  let __net11 = Lazy.force net11 in
  let __ethernet1 = Lazy.force ethernet1 in
  let __arp1 = Lazy.force arp1 in
  let __ipv411 = Lazy.force ipv411 in
  let __icmpv41 = Lazy.force icmpv41 in
  let __udp1 = Lazy.force udp1 in
  let __tcp1 = Lazy.force tcp1 in
  __time1 >>= fun _time1 ->
  __random1 >>= fun _random1 ->
  __net11 >>= fun _net11 ->
  __ethernet1 >>= fun _ethernet1 ->
  __arp1 >>= fun _arp1 ->
  __ipv411 >>= fun _ipv411 ->
  __icmpv41 >>= fun _icmpv41 ->
  __udp1 >>= fun _udp1 ->
  __tcp1 >>= fun _tcp1 ->
  Tcpip_stack_direct1.connect _net11 _ethernet1 _arp1 _ipv411 _icmpv41 _udp1 _tcp1
  )

let tcp_conduit_connector1 = lazy (
  let __stackv4_1 = Lazy.force stackv4_1 in
  __stackv4_1 >>= fun _stackv4_1 ->
  Lwt.return (Conduit_mirage1.connect _stackv4_1)

  )

let argv_solo51 = lazy (
  Bootvar.argv ()
  )

let console_solo5_01 = lazy (
  Console_solo5.connect "0"
  )

let conduit11 = lazy (
  let __tcp_conduit_connector1 = Lazy.force tcp_conduit_connector1 in
  __tcp_conduit_connector1 >>= fun _tcp_conduit_connector1 ->
  Lwt.return Conduit_mirage.empty >>= _tcp_conduit_connector1 >>=
fun t -> Lwt.return t
  )

let resolver1 = lazy (
  let __random1 = Lazy.force random1 in
  let __mclock1 = Lazy.force mclock1 in
  let __stackv4_1 = Lazy.force stackv4_1 in
  __random1 >>= fun _random1 ->
  __mclock1 >>= fun _mclock1 ->
  __stackv4_1 >>= fun _stackv4_1 ->
  let ns = (Key_gen.resolver ()) in let ns_port = (Key_gen.resolver_port ()) in
let res = Resolver_mirage1.R.init ~ns ~ns_port ~stack:_stackv4_1 () in
Lwt.return res

  )

let pclock1 = lazy (
  return ()
  )

let key1 = lazy (
  let __argv_solo51 = Lazy.force argv_solo51 in
  __argv_solo51 >>= fun _argv_solo51 ->
  return (Functoria_runtime.with_argv (List.map fst Key_gen.runtime_keys) "print_count" _argv_solo51)
  )

let f11 = lazy (
  let __time1 = Lazy.force time1 in
  let __console_solo5_01 = Lazy.force console_solo5_01 in
  let __resolver1 = Lazy.force resolver1 in
  let __conduit11 = Lazy.force conduit11 in
  __time1 >>= fun _time1 ->
  __console_solo5_01 >>= fun _console_solo5_01 ->
  __resolver1 >>= fun _resolver1 ->
  __conduit11 >>= fun _conduit11 ->
  Unikernel1.start _time1 _console_solo5_01 _resolver1 _conduit11
  )

let mirage_logs1 = lazy (
  let __pclock1 = Lazy.force pclock1 in
  __pclock1 >>= fun _pclock1 ->
  let ring_size = None in
  let reporter = Mirage_logs1.create ?ring_size () in
  Mirage_runtime.set_level ~default:Logs.Info (Key_gen.logs ());
  Mirage_logs1.set_reporter reporter;
  Lwt.return reporter
  )

let mirage1 = lazy (
  let __key1 = Lazy.force key1 in
  let __mirage_logs1 = Lazy.force mirage_logs1 in
  let __f11 = Lazy.force f11 in
  __key1 >>= fun _key1 ->
  __mirage_logs1 >>= fun _mirage_logs1 ->
  __f11 >>= fun _f11 ->
  Lwt.return_unit
  )

let () =
  let t =
  Lazy.force key1 >>= fun _ ->
    Lazy.force mirage_logs1 >>= fun _ ->
    Lazy.force mirage1
  in run t

